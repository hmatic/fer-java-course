package hr.fer.zemris.java.custom.scripting.parser;

import hr.fer.zemris.java.custom.collections.ArrayIndexedCollection;
import hr.fer.zemris.java.custom.collections.EmptyStackException;
import hr.fer.zemris.java.custom.collections.ObjectStack;
import hr.fer.zemris.java.custom.scripting.elems.*;
import hr.fer.zemris.java.custom.scripting.lexer.LexerState;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexer;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexerException;
import hr.fer.zemris.java.custom.scripting.lexer.Token;
import hr.fer.zemris.java.custom.scripting.lexer.TokenType;
import hr.fer.zemris.java.custom.scripting.nodes.*;

/**
 * Parses tokens generated by {@link hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexer SmartScriptLexer} into a tree of Nodes.<br>
 * Tree starts with DocumentNode. <br>
 * Everything will be parsed into one of following nodes:<br>
 * {@link hr.fer.zemris.java.custom.scripting.nodes.TextNode TextNode}<br>
 * {@link hr.fer.zemris.java.custom.scripting.nodes.EchoNode EchoNode}<br>
 * {@link hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode ForLoopNode}<br>
 * 
 * @author Hrvoje MatiÄ‡
 * @throws SmartScriptParserException upon wrong input or failure
 */
public class SmartScriptParser {
	/**
	 * First node of document. It is only reference and contains no actual data except references to its children nodes.
	 */
	private DocumentNode documentNode;
	
	/**
	 * Default constructor for SmartScriptParser.
	 * 
	 * @param docBody body of text document
	 */
	public SmartScriptParser(String docBody) {
		SmartScriptLexer lexer = new SmartScriptLexer(docBody);
		try {
			documentNode = parse(lexer);
		} catch(SmartScriptLexerException e) {
			throw new SmartScriptParserException(e.getMessage());
		}
	}
	
	/**
	 * Getter for DocumentNode.
	 * 
	 * @return document node
	 */
	public DocumentNode getDocumentNode() {
		return documentNode;
	}
	
	
	/**
	 * <p>This method parses all tokens given by {@link hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexer SmartScriptLexer}.<br>
	 * Nodes without any children are: TextNode and EchoNode<br>
	 * Nodes with children are: ForLoopNode<br>
	 * DocumentNode is main node.<br>
	 * Parser will rethrow lexer exceptions but also check for validity of for tags.<br>
	 * Also all FOR tags need to be closed by END, or exception will be thrown.</p>
	 * 
	 * @param lexer lexer used by parser
	 * @return document node
	 * @throws SmartScriptParserException in case of input that can't be parsed properly or failure
	 */
	private DocumentNode parse(SmartScriptLexer lexer) {
		ObjectStack stack = new ObjectStack();
		stack.push(new DocumentNode());

		Token token;
		do {
			token = lexer.nextToken();
			Node lastNode;
			try {
				lastNode = (Node) stack.peek();
			} catch(EmptyStackException e) {
				throw new SmartScriptParserException("Invalid input. Trying to use empty stack.");
			}
			
			if(token.getType()==TokenType.TEXT) { // CREATE TEXTNODE
				lastNode.addChildNode(new TextNode(token.getValue().toString()));
				
			} else if(token.getType()==TokenType.TAG) { // CREATE ECHONODE OR FORLOOPNODE
				lexer.setState(LexerState.TAG);
				lexer.nextToken();
			
				if(lexer.getToken().getValue().equals('=')) { // CREATE ECHONODE
					Node echoNode = makeEchoNode(lexer);
					
					lastNode.addChildNode(echoNode);
					
					lexer.setState(LexerState.TEXT);
				} else if(((String) lexer.getToken().getValue()).toUpperCase().equals("FOR")) { // CREATE FORLOOPNODE
					Node forLoopNode = makeForLoopNode(lexer);
					
					lastNode.addChildNode(forLoopNode);
					
					stack.push(forLoopNode);
					lexer.setState(LexerState.TEXT);
				} else if(((String) lexer.getToken().getValue()).toUpperCase().equals("END")) { // END TAG, POP LAST NODE FROM STACK
					stack.pop();
					if(stack.size() == 0) throw new SmartScriptParserException("More end tags than opened tags");
					
					lexer.nextToken();
					lexer.setState(LexerState.TEXT);
				}
			}
		} while(token.getType()!=TokenType.EOF);
		
		if(stack.size()==1) {
			DocumentNode documentNode = (DocumentNode) stack.pop();
			return documentNode;
		} else {
			throw new SmartScriptParserException("Less end tags than opened tags");
		}
		
	}
	
	/**
	 * Method that handles parsing and creation of EchoNodes.
	 * 
	 * @param lexer reference to lexer used for creation
	 * @return new EchoNode
	 * @throws SmartScriptParserException in case of failure
	 */
	private static Node makeEchoNode(SmartScriptLexer lexer) {
		ArrayIndexedCollection elements = new ArrayIndexedCollection();
		
		do {
			lexer.nextToken();
			
			switch(lexer.getToken().getType()) {
				case VARIABLE:
					elements.add(new ElementVariable(lexer.getToken().getValue().toString()));
					break;
				case STRING:
					elements.add(new ElementString(lexer.getToken().getValue().toString()));
					break;
				case OPERATOR:
					elements.add(new ElementOperator(lexer.getToken().getValue().toString()));
					break;
				case FUNCTION:
					elements.add(new ElementFunction(lexer.getToken().getValue().toString()));
					break;
				case INTEGER:
					elements.add(new ElementConstantInteger((int)lexer.getToken().getValue()));
					break;
				case DOUBLE:
					elements.add(new ElementConstantDouble((double)lexer.getToken().getValue()));
					break;
				case TAG:
					break;
				default:
					throw new SmartScriptParserException("Not valid token inside echonode");
					
			}
		} while(!lexer.getToken().getValue().equals("$}"));
	
		Element[] elems = new Element[elements.size()];
		for(int i=0, size=elements.size(); i<size; i++) {
			elems[i]=(Element) elements.get(i);
		}
		return new EchoNode(elems);
	}
	
	/**
	 * Method that handles parsing and creation of ForLoopNodes.
	 * 
	 * @param lexer reference to lexer used for creation
	 * @return new ForLoopNode
	 * @throws SmartScriptParserException in case of failure
	 */
	private static Node makeForLoopNode(SmartScriptLexer lexer) {
		ElementVariable variable;
		Element start;
		Element end;
		Element step;
		
		if(lexer.nextToken().getType()==TokenType.VARIABLE) {
			variable = new ElementVariable(lexer.getToken().getValue().toString());
		} else {
			throw new SmartScriptParserException("Invalid content in for tag.");
		}
		
		Token startToken = lexer.nextToken();
		Token endToken = lexer.nextToken();
		if(checkForNodeToken(startToken) && checkForNodeToken(endToken)) {
			start = constructElement(startToken);
			end = constructElement(endToken);
		} else {
			throw new SmartScriptParserException("Invalid content in for tag.");
		}
		
		lexer.nextToken();
		if(checkForNodeToken(lexer.getToken())) {
			step = constructElement(lexer.getToken());
			if(lexer.nextToken().getType()!=TokenType.TAG) {
				throw new SmartScriptParserException("Invalid content in for tag.");
			}
		} else if(lexer.getToken().getType()==TokenType.TAG) {
			step = null;
		} else {
			throw new SmartScriptParserException("Invalid content in for tag.");
		}					
		
		return new ForLoopNode(variable, start, end, step );
	}
	
	/**
	 * Static factory method which creates new Element based on type of Token.
	 * @param token token to be checked for type
	 * @return new Element object of correct type
	 */
	private static Element constructElement(Token token) {
		if(token.getType()==TokenType.VARIABLE) {
			return new ElementVariable(token.getValue().toString());
		} else if(token.getType()==TokenType.DOUBLE) {
			return new ElementConstantDouble((double)token.getValue());
		} else if(token.getType()==TokenType.INTEGER) {
			return new ElementConstantInteger((int)token.getValue());
		} else if(token.getType()==TokenType.STRING) {
			return new ElementString(token.getValue().toString());
		} else {
			throw new SmartScriptParserException("Invalid input.");
		}
		
	}
	
	/**
	 * Static method which checks if token type is appropriate for arguments of ForLoopNode.
	 * 
	 * @param token to be evaluated
	 * @return true if token can go inside ForLoopNode, false otherwise
	 */
	private static boolean checkForNodeToken(Token token) {
		if(token.getType()==TokenType.VARIABLE) return true;
		if(token.getType()==TokenType.DOUBLE) return true;
		if(token.getType()==TokenType.INTEGER) return true;
		if(token.getType()==TokenType.STRING) return true;
		return false;
	}
}
